\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}

\parindent=1cm
\makeatletter
\newcommand{\rindex}[2][\imki@jobname]{%
    \index[#1]{\detokenize{#2}}%
}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\hfuzz=10000pt
\vbadness10000
\linespread{1}

%\linespread{1.1}
% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискретного\\ анализа: сортировка за линейное время}

Выполнил студент группы 08-30X МАИ \textit{Лопатин Александр}.
\subsection*{Условие}

Требуется разработать программу, осуществляющую ввод пар ``ключ-значение'' и их сортировку за линейное время: 
\begin{enumerate}
\item На каждой непустой строке входного файла располагается пара ``ключ-значение'', разделённые знаком табуляции. В выходных данных должны быть отсортированные строки исходной последовательности (за исключением пустых)
\item Вариант задания: 7-3
\begin{itemize}

 \item[\textbf{ \it Ключи---}] Автомобильные номера в формате A 999 BC (используются буквы латинского алфавита).
 \item[\textbf{ \it Значения---}] Числа от 0 до $2^{64} - 1$.

\end{itemize}
\end{enumerate}

\subsection*{Метод решения}
    \begin{enumerate}
    
    \item  Данные на вход программе подаются через перенаправление вывода из файла, и, как следствие, весьма удобно считывать циклом while(особенно это важно при неизвестном количестве строк).\\ Когда будет считан символ EOF, цикл завершится.
    
    
    \item Предусмотрена работа программы с неизвестным количеством входных данных.

    
    \item Для работы алгоритма был введен вспомогательный массив: для каждой цифры j, которая может стоять на i-ом разряде, значением j-того элемента этого массива будет количество таких элементов пар ''ключ-значение'', что у ключа на i-ом разряде стоит цифра j.

    \item Алгоритм сортировки принимает на вход ссылку на массив пар ''ключ-значение'' и его размер. Результатом работы алгоритма будет отсортированный массив, содержащийся по начальной ссылке (т.е. алгоритм сортирует сам массив, не создавая его копию).
\end{enumerate}
%Общее описание алгоритма решения задачи, архитектуры программы и т.\,п. Полностью расписывать алгоритмы необязательно, но в общих чертах описать нужно. Приветствуются ссылки на внешние источники, использованные при подготовке (книги, интернет-ресурсы). 


\subsection*{Описание программы}

\begin{itemize}
    \item \textbf{lab1.cpp}\\ 
    Основной файл, содержит в себе собственно функцию ``main'' и функцию сортировки ``RadixSort''
    \item \textbf{lab1.h}\\
    Заголовок основного файла, в котором находится описание всех используемых структур и констант.
\end{itemize}
%Разделение по файлам, описание основных типов данных и функций. 

\subsection*{Дневник отладки}
При создании следующей таблицы была использована история локального гит-репозитория.
\smallbreak
\noindent
\begin{tabular}{|l|p{2.7cm}|P{0.675\linewidth}|}
    \hline
    Время& Коммит& Описание \\ \hline
    11 21:22:25&init &Начало работы, есть только шаблоны файлов и функций\\ \hline
    11 22:05:16& parsing& Заготовки под функцию парсинга, поиск необходимых методов и тестирование функции + 3 таких же коммита\\   \hline
    11 22:16:57&оптимизация указателей& Изменение структуры ключа, замена строки ссылкой на элемент отдельного массива строк\\ \hline
    12 13:31:19&убрал утечки памяти&Не освобождалась вся память, в самой структуре ключа я выделил память для указателя на строку, потом это значение перезаписывалось с ввода, а выделенная ранее память не освобождалась\\ \hline
    12 13:55:02&доделать сортировку &Была проблема с логикой алгоритма сортировки, цикл завершался досрочно, либо значения не отсортировывались в нужном порядке + 3 коммита мелкие исправления\\ \hline
    15 21:33:11&cut last symbol&Заметил, что обрезается последний символ строки-значения + 18 коммитов на то, чтобы понять, что необходимо создать механизм динамического расширения выделенной памяти\\ \hline
    19 14:36:07&WORKING!!!!&Рабочая версия программы, чекер отправил ОК, далее проходила незначительная оптимизация кода и кодстайла\\ \hline
    22 11:39:58& string->char*& Узнал что такое стандартные контейнеры STL в С++, пришлось переводить все вхождения на массив char-ов\\ \hline
    22 21:47:39&Conditional jump or move & Надо было учесть, что строки обязаны заканчиваться символом $\backslash 0$, для корректной обработки строк \\ \hline
    
\end{tabular}
\smallbreak


Так же при проверке работы программы учитывалось время её исполнения (утилита time), осуществлялся контроль различных ошибок и утечек памяти (утилита valgrind) и отдельно для тестов применялась утилита memusage.
%Что и когда делали, что не работало, как чинили. Этот пункт обязательный, если было сделано несколько посылок. Кратко опишите суть проблемы и способ ее устранения.

\subsection*{Тест производительности}
Тесты создавались с помощью небольшой программы на языке Python:
\begin{lstlisting}[language=python]
import random

for i in range(10000, 120000, 10000):
    file = open('tests/test'+str(i)+'.txt','w') 
    for j in range(1, i):
        file.write(str(random.randint(0,9))
            +chr(random.randint(65,90))
            +chr(random.randint(65,90))
            +chr(random.randint(65,90))
            +str(random.randint(0,9))
            +str(random.randint(0,9))
            +'\t'
            +str(random.randint(0,4294967295))
            +'\n')
    file.close()

\end{lstlisting}
\begin{table}
    \centering

\begin{tabular}{|c |m{5cm}|}
    \hline
    Размер файла& Имя файла и количество тысяч строк в нём\\ \hline
    4,1M&   100k\\
    
    8,1M&   200k\\
    
    13M &   300k\\
    
    17M &   400k\\
    
    21M &   500k\\
    
    25M &   600k\\
    
    29M &   700k\\
    
    33M &   800k\\
    
    37M &   900k\\ \hline
\end{tabular}
\end{table}

\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=Количество строк, width=15.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 110000, 0.64 )
        ( 100000, 0.58 )
        ( 90000, 0.52  )
        ( 80000, 0.46 )
        ( 70000, 0.41  )
        ( 60000, 0.34 )
        ( 50000, 0.29 )
        ( 40000, 0.23 )
        ( 30000, 0.18 )
        ( 20000, 0.16 )
        ( 10000, 0.05  )};
    \addplot coordinates {
    ( 10000, 0.05)
    ( 110000, 0.68 )};
    \end{axis}

\end{tikzpicture}

Итого, по графику результатов времени выполнения программы, её сложность близка к линейной.
\\

\begin{tikzpicture}
\begin{axis}[ylabel=Килобайты,xlabel=Количество строк, width=15.5cm, height=10cm,grid=both]
\addplot coordinates {
    (   10000, 3343   ) 
    (  20000, 3744  )
    ( 30000,  3900  )
    ( 40000,  4212   )
    ( 50000, 4420 )
    ( 60000, 5136  )
    ( 70000, 5380  )
    ( 80000, 5648  )
    ( 90000, 5776  )
    ( 100000, 5964 )
    ( 110000, 6516 )};
\end{axis}
\end{tikzpicture}

Небольшой изгиб графика обусловлен тем, что при заполнении выделенной памяти выделяется дополнительная память для $100\ 000$ значений, а не для одного, что более логично, но менее эффективно. При числах, на порядок больших чем размер изначально выделяемой памяти, зависимость размера выделяемой памяти приближается к линейной.


%Померить время работы кода лабораторной и теста производительности на разных объемах входных данных. Сравнить результаты. Проверить, что рост времени работы при увеличении объема входных данных согласуется с заявленной сложностью.


\subsection*{Недочёты}

%\smallbreak
В ходе проверки работы на чекере выяснилось, что весьма важной характеристикой работы программы является время вывода данных в консоль (например для 1 000 000 входных строк только вывод конечного результата работы программы занимал 7.1 секунды, при времени сортировки около 0.9 секунд). Было найдено несколько способов оптимизации вывода, применимых для С++. 

Наиболее результативным оказалось использование printf в качестве вывода и опции std::ios\_base::sync\_with\_stdio(false), которая отключает синхронизацию потоков Си и С++. Т.~е. не происходит копирование данных из буфера в буфер, что даёт некоторый выигрыш в скорости вывода данных на стандартный вывод.

%Описать те проблемы, которые остались нерешёнными в программе. Если
%выявленных недочётов нет, то этот пункт можно пропустить. Если же
%задача была принята с оговорками (медленно работает, неверно выполняет
%какие-то тесты), то нужно обязательно их упомянуть, привести возможные
%причины, указать почему не получилось исправить недочёты. 
%\newpage
\subsection*{Выводы}


Данную программу можно применять для сортировки важных исторических событий, для их последующей обработки и добавления, например, в учебник.\\

Также существует вариант создания базы данных военкомата, в которой в роли строки-значения будет выступать адрес проживания призывника, а в качестве ключа будет использоваться дата рождения. Такая база, отсортированная по дате рождения обеспечивает более лёгкий анализ данных о призывниках текущего года.\\


Написание программы было сложным из за отсутствия навыков работы с языком С++, большая часть времени была потрачена на поиск оптимального, кратчайшего и эффективного способа выполнения функций.


Проблемы возникали при работе с указателями на динамические массивы, часто встречались логические ошибки при выделении, освобождении и перезаписи ячеек памяти.


В целом написание даной лабораторной было полезным, так как послужило поводом к изучению механизмов динамического выделения памяти, и методов парсинга строк. Понимание этих алгоритмов важно для написания эффективного и лаконичного кода. 


%Описать область применения реализованного алгоритма. Указать типовые
%задачи, решаемые им. Оценить сложность программирования, кратко
%описать возникшие проблемы при решении задачи. 

\end{document}
