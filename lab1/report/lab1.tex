\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}

\parindent=1cm
\makeatletter
\newcommand{\rindex}[2][\imki@jobname]{%
    \index[#1]{\detokenize{#2}}%
}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\hfuzz=10000pt
\vbadness10000
\linespread{1}

%\linespread{1.1}
% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискретного\\ анализа: сортировка за линейное время}

Выполнил студент группы 08-307 МАИ \textit{Лопатин Александр}.
\subsection*{Условие}

Требуется разработать программу, осуществляющую ввод пар ``ключ-значение'' и их сортировку за линейное время: 
\begin{enumerate}
\item На каждой непустой строке входного файла располагается пара ``ключ-значение'', разделённые знаком табуляции. В выходных данных должны быть отсортированные строки исходной последовательности (за исключением пустых)
\item Вариант задания: 7-3
\begin{itemize}

 \item[\textbf{ \it Ключи---}] Автомобильные номера в формате A 999 BC (используются буквы латинского алфавита).
 \item[\textbf{ \it Значения---}] Числа от 0 до $2^{64} - 1$.

\end{itemize}
\end{enumerate}

\subsection*{Метод решения}
    \begin{enumerate}
    
    \item  Данные на вход программе подаются через перенаправление вывода из файла, и, как следствие, весьма удобно считывать циклом while(особенно это важно при неизвестном количестве строк).\\ Когда будет считан символ EOF, цикл завершится.
    
    
    \item Предусмотрена работа программы с неизвестным количеством входных данных.

    
    \item Для работы алгоритма был введен вспомогательный массив: для каждой цифры j, которая может стоять на i-ом разряде, значением j-того элемента этого массива будет количество таких элементов пар ''ключ-значение'', что у ключа на i-ом разряде стоит цифра j.

    \item Алгоритм сортировки принимает на вход ссылку на массив пар ''ключ-значение'' и его размер. Результатом работы алгоритма будет отсортированный массив, содержащийся по начальной ссылке (т.е. алгоритм сортирует сам массив, не создавая его копию).
\end{enumerate}
%Общее описание алгоритма решения задачи, архитектуры программы и т.\,п. Полностью расписывать алгоритмы необязательно, но в общих чертах описать нужно. Приветствуются ссылки на внешние источники, использованные при подготовке (книги, интернет-ресурсы). 


\subsection*{Описание программы}

\begin{itemize}
    \item \textbf{lab1.cpp}\\ 
    Основной файл, содержит в себе собственно функцию ``main'' и функцию сортировки ``RadixSort''
    \item \textbf{lab1.h}\\
    Заголовок основного файла, в котором находится описание всех используемых структур и констант.
\end{itemize}
%Разделение по файлам, описание основных типов данных и функций. 

\subsection*{Дневник отладки}
При создании следующей таблицы была использована история локального гит-репозитория.
\smallbreak
\noindent
\begin{tabular}{|l|p{2.7cm}|P{0.675\linewidth}|}
    \hline
    Время& Коммит& Описание \\ \hline
    11 21:22:25&init &Начало работы, есть только шаблоны файлов и функций\\ \hline
    11 22:05:16& parsing& Заготовки под функцию парсинга, поиск необходимых методов и тестирование функции + 3 таких же коммита\\   \hline
    11 22:16:57&оптимизация указателей& Изменение структуры ключа, замена строки ссылкой на элемент отдельного массива строк\\ \hline
    12 13:31:19&убрал утечки памяти&Не освобождалась вся память, в самой структуре ключа я выделил память для указателя на строку, потом это значение перезаписывалось с ввода, а выделенная ранее память не освобождалась\\ \hline
    12 13:55:02&доделать сортировку &Была проблема с логикой алгоритма сортировки, цикл завершался досрочно, либо значения не отсортировывались в нужном порядке + 3 коммита мелкие исправления\\ \hline
    15 21:33:11&cut last symbol&Заметил, что обрезается последний символ строки-значения + 18 коммитов на то, чтобы понять, что необходимо создать механизм динамического расширения выделенной памяти\\ \hline
    19 14:36:07&WORKING!!!!&Рабочая версия программы, чекер отправил ОК, далее проходила незначительная оптимизация кода и кодстайла\\ \hline
    22 11:39:58& string->char*& Узнал что такое стандартные контейнеры STL в С++, пришлось переводить все вхождения на массив char-ов\\ \hline
    22 21:47:39&Conditional jump or move & Надо было учесть, что строки обязаны заканчиваться символом $\backslash 0$, для корректной обработки строк \\ \hline
    
\end{tabular}
\smallbreak


Так же при проверке работы программы учитывалось время её исполнения (утилита time), осуществлялся контроль различных ошибок и утечек памяти (утилита valgrind) и отдельно для тестов применялась утилита memusage.
%Что и когда делали, что не работало, как чинили. Этот пункт обязательный, если было сделано несколько посылок. Кратко опишите суть проблемы и способ ее устранения.

\subsection*{Тест производительности}
Тесты создавались с помощью небольшой программы на языке Python:
\begin{lstlisting}[language=python]
import random

for i in range(10000, 120000, 10000):
    file = open('tests/test'+str(i)+'.txt','w') 
    for j in range(1, i):
        file.write(str(random.randint(0,9))
            +chr(random.randint(65,90))
            +chr(random.randint(65,90))
            +chr(random.randint(65,90))
            +str(random.randint(0,9))
            +str(random.randint(0,9))
            +'\t'
            +str(random.randint(0,4294967295))
            +'\n')
    file.close()

\end{lstlisting}
\begin{table}
    \centering

\begin{tabular}{|c |m{5cm}|}
    \hline
    Размер файла& Имя файла и количество тысяч строк в нём\\ \hline
    4,1M&   100k\\
    
    8,1M&   200k\\
    
    13M &   300k\\
    
    17M &   400k\\
    
    21M &   500k\\
    
    25M &   600k\\
    
    29M &   700k\\
    
    33M &   800k\\
    
    37M &   900k\\ \hline
\end{tabular}
\end{table}

\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=Количество строк, width=15.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 110000, 0.64 )
        ( 100000, 0.58 )
        ( 90000, 0.52  )
        ( 80000, 0.46 )
        ( 70000, 0.41  )
        ( 60000, 0.34 )
        ( 50000, 0.29 )
        ( 40000, 0.23 )
        ( 30000, 0.18 )
        ( 20000, 0.16 )
        ( 10000, 0.05  )};
    \addplot coordinates {
    ( 10000, 0.05)
    ( 110000, 0.68 )};
    \end{axis}

\end{tikzpicture}

Итого, по графику результатов времени выполнения программы, её сложность близка к линейной.
\\

\begin{tikzpicture}
\begin{axis}[ylabel=Килобайты,xlabel=Количество строк, width=15.5cm, height=10cm,grid=both]
\addplot coordinates {
    (   10000, 3343   ) 
    (  20000, 3744  )
    ( 30000,  3900  )
    ( 40000,  4212   )
    ( 50000, 4420 )
    ( 60000, 5136  )
    ( 70000, 5380  )
    ( 80000, 5648  )
    ( 90000, 5776  )
    ( 100000, 5964 )
    ( 110000, 6516 )};
\end{axis}
\end{tikzpicture}


%Померить время работы кода лабораторной и теста производительности на разных объемах входных данных. Сравнить результаты. Проверить, что рост времени работы при увеличении объема входных данных согласуется с заявленной сложностью.

\subsection*{Выводы}

Данный алгоритм хорошо подойдет для сортировки объектов с ограниченным количеством разрядов (например, переменных типа int или, как в этом варианте, автомобильных номеров), но деградирует с линейной до квадратической при неограниченном (например, string).


%Описать область применения реализованного алгоритма. Указать типовые
%задачи, решаемые им. Оценить сложность программирования, кратко
%описать возникшие проблемы при решении задачи. 

\end{document}
