\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{ulem} 

\lstset{language=C++,
	basicstyle=\footnotesize\sffamily,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=false % переносить строки только если есть пробел
}
\parindent=1cm
\makeatletter

\newcommand{\print}[1]{{\large  \bf  #1} 
{\scriptsize \lstinputlisting[language=C++]{../#1}}}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\linespread{1}
%\pgfplotsset{compat=1.16}
\begin{document}

\section*{\centering Лабораторная работа №\,5 по курсу:\\ Дискретный анализ}

Выполнил студент группы М8О-307Б-17 МАИ \,\, \textit{Лопатин Александр}.

\subsection*{Задача}

\paragraph*{Вариант 2}: Поиск с использованием суффиксного
массива\\
Найти в заранее известном тексте поступающие на вход образцы с
использованием суффиксного массива. Формат входных и выходных
данных, а так же примеры аналогичны указанным во первом задании.

\textit{ \textbf{Входные данные}}: 
Текст располагается на первой строке, затем, до конца
файла, следуют строки с образцами.


\textit{ \textbf{Выходные данные}}: 
Для каждого образца, найденного в тексте, нужно
распечатать строчку, начинающуюся с последовательного номера этого
образца и двоеточия, за которым, через запятую, нужно перечислить
номера позиций, где встречается образец в порядке возрастания.

\subsection*{Информация}

Суффиксное дерево (сжатое суффиксное дерево) T для строки s (где |s| = n) — дерево с n листьями, обладающее следующими свойствами:
\begin{enumerate}
	\item каждая внутренняя вершина дерева имеет не меньше двух детей;
	\item каждое ребро помечено непустой подстрокой строки s;
	\item никакие два ребра, выходящие из одной вершины, не могут иметь пометок, начинающихся с одного и того же символа;
	\item дерево должно содержать все суффиксы строки s, причем каждый суффикс заканчивается точно в листе и нигде кроме него.
\end{enumerate}

Cуффиксным массивом (англ. suffix array) строки $s[1..n]$ называется массив suf целых чисел от 1 до n, такой, что суффикс $s[suf[i]..n]$ — i-й в лексикографическом порядке среди всех непустых суффиксов строки s.

\subsection*{Метод решения}

Можно построить суффиксное дерево с помощью алгоритма Укконена за линейное время, потом пройтись по листам (чтобы каждый суффикс имел свой лист, добавим в конец строки символ, который ранее в тексте не встречался) и в лексикографическом порядке добавить их в суффиксный массив. Так как в дальнейшем мы будем работать только с суффиксным массивом, удалим из памяти суффиксное дерево. Далее, на каждый запрос поиска образца с помощью бинарного поиска находим левую и правую границы в суффиксном массиве всех суффиксов, для которых образец является префиксом, и сортируем их по длине суффикса ( т.к. по условию задания нужно перечислить номера позиций, где встречается образец в порядке возрастания ). Алгоритм Укконена и построение суффиксного массива имеют асимптотическую сложность $O(n)$, бинарный поиск и сортировка номеров позиций в сумме будут иметь асимпотитечкую сложность $O(p*log n + q * log q)$, где n - длина исходной строки, p - длина образца, q - длина интервала результата работы бинарного поиска (сортировка занимает $O(q*log q)$ времени).

\subsection*{Генератор тестов}
\print{tests.py}

\subsection*{Проверка производительности}
Время построения суффиксного дерева с помощью алгоритма Укконена: \\ \\
\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=Длина строки, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 100000, 0.30 )
        ( 90000, 0.27 )
        ( 80000, 0.24 )
        ( 70000, 0.21 )
        ( 60000, 0.18 )
        ( 50000, 0.15 )
        ( 40000, 0.12 )
        ( 30000, 0.09 )
        ( 20000, 0.06 )
        ( 10000, 0.04  )};
    \end{axis}
\end{tikzpicture}
\\Использование памяти:\\ \\
\begin{tikzpicture}
    \begin{axis}[ylabel=Килобайт,xlabel=Длина строки, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 100000, 42152 )
        ( 90000, 38024 )
        ( 80000, 34136 )
        ( 70000, 30472 )
        ( 60000, 26462 )
        ( 50000, 22592 )
        ( 40000, 18536 )
        ( 30000, 14700 )
        ( 20000, 11028 )
        ( 10000, 6960  )};
    \end{axis}
\end{tikzpicture}

% \lstinputlisting[language=Python]{../../lab08/gen.py}
\subsection*{Выводы}

Алгоритм Укконена позволяет построить суффиксное дерево для заранее известного текста за линейное относительно длины строки время. Плюсом является то, что это on-line алгоритм, который дополняет на каждом шаге суффиксное дерево следующим символом. Причем, как было сказано ранее, текст заранее известен, поэтому он хорошо подходит для задач, когда шаблоны поиска заранее неизвестны. Большой минус этого алгоритма в том, что он требователен к памяти: для каждого следующего шага ему требуется содержать все суффиксное дерево в оперативной памяти, однако можно модифицировать алгоритм, чтобы он не хранил все дерево в ней, но это не так и просто реализовать. Можно заметить, что алгоритм Укконена на самом деле работает за время $O(k*n)$ и использует столько же памяти, где k - размер алфавита. Поэтому, если алфавит очень большой требуется чрезмерный объем памяти. Можно сэкономить на памяти, храня в каждой вершине только те символы, по которым из нее есть переходы, но тогда поиск перехода будет занимать $O(log k)$ времени.
\end{document}