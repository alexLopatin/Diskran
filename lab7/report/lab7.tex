\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{ulem} 

\lstset{
	language=C++,
	basicstyle=\footnotesize\sffamily,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=false % переносить строки только если есть пробел
}
\parindent=1cm
\makeatletter
% \newcommand{\rindex}[2][\imki@jobname]{%
    % \index[#1]{\detokenize{#2}}%
% }
\newcommand{\print}[1]{{\large  \bf  #1} {\scriptsize \lstinputlisting[language=C++]{../../lab07/#1}}}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\linespread{1}
\pgfplotsset{compat=1.15}
\begin{document}

\section*{\centering Лабораторная работа №\,7 по курсу:\\ Дискретный анализ}

Выполнил студент группы М8О-30ХБ-17 МАИ \,\, \textit{Лопатин Александр}.

\subsection*{Задача}

При помощи метода динамического программирования разработать алгоритм решения задачи, определяемой своим вариантом; оценить время выполнения
алгоритма и объём затрачиваемой оперативной памяти. Перед выполнением задания
необходимо обосновать применимость метода динамического программирования.
Разработать программу на языке C или C++, реализующую построенный алгоритм.
Формат входных и выходных данных описан в варианте задания.

\paragraph*{Вариант 4:} Игра с числом.\\

Имеется натуральное число n. За один ход с ним можно произвести следующие действия:
\begin{itemize}
\itemВычесть единицу;
\itemРазделить на два;
\itemРазделить на три.
\end{itemize}

При этом стоимость каждой операции - текущее значение n. Стоимость преобразования - суммарная
стоимость всех операций в преобразовании. Вам необходимо с помощью последовательностей указанных
операций преобразовать число n в единицу таким образом, чтобы стоимость преобразования была
наименьшей. Делить можно только нацело.\\


\subsection*{Информация}

Динамическое программирование -- это способ решения сложных задач, путём разбиения их на подзадачи.Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с ``наивными'' методами, можно значительно сократить.

\noindent Этапы построения алгоритма решения подзадач:
\begin{itemize}
\item  Описать структуру оптимального решения.
\item Составить рекурсивное решение для нахождения оптимального решения.
\item 	Вычисление значения, соответствующего оптимальному решению, методом восходящего анализа.
\item 	Непосредственное нахождение оптимального решения из полученной на предыдущих этапах информации.
	
\end{itemize}

\subsection*{Метод решения}

Для того, чтобы решить данную задачу, можно пойти с другого конца: будем рекуррентно считать минимальные стоимости для каждого числа начиная с 1 и заканчивая n и записывать эти значения в массив dp. Будем считать, что значения dp[0] и dp[1] присвоены нулю. Тогда, для числа i следует рекуррентная формула:\\

a) если i кратно 6, то $i = i + min( dp[ i - 1 ], dp[ i / 2], dp[ i / 3 ] )$ \\

б) если i кратно 3, но не кратно 2, то $i = i + min( dp[ i - 1 ], dp[ i / 3 ] )$\\

в) если i кратно 2, но не кратно 3, то $i = i + min( dp[ i - 1 ], dp[ i / 2 ] )$\\

г) если i не кратно ни 2, ни 3, то $i = i + dp[ i - 1 ]$\\

Докажем справедливость этой формулы. Предположим, что dp[i - 1], dp[i/2], dp[i/3] являются минимальными стоимостями для чисел i-1, i/2, i/3 соответственно (Начало индукции - dp[0] = 0, dp[1] = 0 являются минимальными). Достичь числа i можно несколькими способами: либо если i кратно 3 перейти из числа i/3, либо если i кратно 2 перейти из числа i/2, либо перейти из числа i - 1.  Очевидно, что оптимальным вариантом будет самый наименьший по стоимости путь, так как если выбрать не наименьший, то минимальной стоимость считаться уже не будет. 

\subsection*{Описание программы}

Для вычисления значения минимальной стоимости числа n используется массив длиной n+1, который хранит значения оптимальной стоимости всех чисел от 0 до n, следовательно сложности по памяти и по времени составляют O(n). 

\begin{itemize}
    \item \textbf{lab7.cpp}\\ 
    Единственный файл, содержит в себе решение данной задачи.
\end{itemize}

\subsection*{Дневник отладки}
\smallbreak
\noindent
\begin{tabular}{|l|p{13.2cm}|P{0.675\linewidth}|}
    \hline
    Время&  Описание \\ \hline
    13.07 00:12:05& Было подобрано наивное решение с помощью жадного алгоритма, которое в итоге не подходило к данной задаче\\ \hline
    13.07 02:14:23& Описана рекуррентная формула\\ \hline
    13.07 02:19:36& Программа исправно работает на нескольких тестах\\ \hline
    13.07 02:28:57& Программа успешно прошла ряд тестов на производительность\\ \hline
\end{tabular}
\smallbreak
\subsection*{Тест производительности}

Тесты создавались с помощью скрипта, написанного на Python:
\begin{lstlisting}[language=python]
for i in range(1, 11, 1):
    file = open('tests/test'+str(i)+'.txt','w')
    file.write(str((1000000*i)))
    file.close()
\end{lstlisting}

Время и использованная память были измерены с помощью встроенной утилиты time.\\

\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=n, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 10000000, 0.30 )
        ( 9000000, 0.27 )
        ( 8000000, 0.24 )
        ( 7000000, 0.21 )
        ( 6000000, 0.18 )
        ( 5000000, 0.15 )
        ( 4000000, 0.12 )
        ( 3000000, 0.09 )
        ( 2000000, 0.06 )
        ( 1000000, 0.04  )};
    \addplot coordinates {
    ( 1000000, 0.04)
    ( 10000000, 0.30 )};
    \end{axis}

\end{tikzpicture}

Итого, по графику результатов времени выполнения программы, её сложность близка к линейной.
\\

\begin{tikzpicture}
\begin{axis}[ylabel=Килобайты,xlabel=n, width=13.5cm, height=10cm,grid=both]
\addplot coordinates {
    ( 10000000, 42152 )
    ( 9000000, 38024 )
    ( 8000000, 34136 )
    ( 7000000, 30472 )
    ( 6000000, 26496 )
    ( 5000000, 22592 )
    ( 4000000, 18536 )
    ( 3000000, 14700 )
    ( 2000000, 11028 )
    ( 1000000, 6960 )};
\end{axis}
\end{tikzpicture}

Судя по графику, сложность по памяти приблизительно равна линейной. \\

\subsection*{Выводы}

Динамическое программирование довольно распространено, в различных олимпиадах около половины задач решаются с помощью ДП. Всюду, где встречаются подзадачи, и где их можно легко выделить, динамическое программирование позволяет существенно ускорить работу программы. 

\end{document}