\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{ulem} 

\lstset{language=C++,
	basicstyle=\footnotesize\sffamily,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=false % переносить строки только если есть пробел
}
\parindent=1cm
\makeatletter

\newcommand{\print}[1]{{\large  \bf  #1} 
{\scriptsize \lstinputlisting[language=C++]{../#1}}}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\linespread{1}
%\pgfplotsset{compat=1.16}
\begin{document}

\section*{\centering Лабораторная работа №\,2 по курсу:\\ Дискретный анализ}

Выполнил студент группы М8О-307Б-17 МАИ \,\, \textit{Лопатин Александр}.

\subsection*{Задача}
\begin{itemize}
\item {\bf Постановка задачи:}\subitem Необходимо создать программную библиотеку, реализующую указанную структуру данных, на основе которой разработать программу-словарь. В словаре каждому ключу, представляющему из себя регистронезависимую последовательность букв английского алфавита длиной не более 256 символов, поставлен в соответствие некоторый номер, от 0 до $2^{64} - 1$. Разным словам может быть поставлен в соответствие один и тот же номер.

\item {\bf Вариант дерева: }\subitem  Красно-черное дерево

\item{ \bf Вариант ключа:} \subitem Регистронезависимая последовательность букв английского алфавита длиной не более 256 символов.


\item {\bf Вариант значения:} \subitem   Числа от $0$ до $2^{64} − 1$.

\end{itemize}

\subsection*{Информация}

Красно-чёрным называется бинарное поисковое дерево, у которого каждому узлу сопоставлен дополнительный атрибут — цвет и для которого выполняются следующие свойства:\\
\begin{itemize}
\item Каждый узел промаркирован красным или чёрным цветом
\item Корень и конечные узлы (листья) дерева — чёрные
\item У красного узла родительский узел — чёрный
\item Все простые пути из любого узла x до листьев содержат одинаковое количество чёрных узлов
\item Чёрный узел может иметь чёрного родителя
\end{itemize}




\subsection*{Метод решения}

\subsubsection*{Вставка}

Чтобы вставить узел, мы сначала ищем в дереве место, куда его следует добавить. Новый узел всегда добавляется как лист, поэтому оба его потомка являются NIL-узлами и предполагаются черными. После вставки красим узел в красный цвет. После этого смотрим на предка и проверяем, не нарушается ли красно-черное свойство. Если необходимо, мы перекрашиваем узел и производим поворот, чтобы сбалансировать дерево.

\subsubsection*{Удаление}

При удалении вершины могут возникнуть три случая в зависимости от количества её детей:
\begin{itemize}
\item Если у вершины нет детей, то изменяем указатель на неё у родителя на nil.
\item Если у неё только один ребёнок, то делаем у родителя ссылку на него вместо этой вершины.
\item Если же имеются оба ребёнка, то находим вершину со следующим значением ключа. У такой вершины нет левого ребёнка (так как такая вершина находится в правом поддереве исходной вершины и она самая левая в нем, иначе бы мы взяли ее левого ребенка. Иными словами сначала мы переходим в правое поддерево, а после спускаемся вниз в левое до тех пор, пока у вершины есть левый ребенок). Удаляем уже эту вершину описанным во втором пункте способом, скопировав её ключ в изначальную вершину.
\end{itemize}

\subsection*{Генератор тестов}
Сначала создаются тесты для создания базы данных и выгрузки её на жесткий диск, потом создаются тесты на выгрузку этих баз данных и поиск в них элементов. tests.py - создание баз данных; SearchTests.py - поиск элементов в базах данных. \\
\print{tests.py}
\print{SearchTests.py}

\subsection*{Тест производительности}
Сложность добавления, поиска и удаления элемента в красно-черном дереве составляет $O(log n)$. 

\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=Количество элементов, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 10000, 0.16 )
        ( 9000, 0.13 )
        ( 8000, 0.12 )
        ( 7000, 0.11 )
        ( 6000, 0.09 )
        ( 5000, 0.07 )
        ( 4000, 0.06 )
        ( 3000, 0.04 )
        ( 2000, 0.03 )
        ( 1000, 0.06  )};
    \end{axis}
\end{tikzpicture}
\\ \\
\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=Запросов поиска, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 10000, 0.06 )
        ( 9000, 0.05 )
        ( 8000, 0.05 )
        ( 7000, 0.04 )
        ( 6000, 0.04 )
        ( 5000, 0.03 )
        ( 4000, 0.02 )
        ( 3000, 0.02 )
        ( 2000, 0.01 )
        ( 1000, 0.06  )};
    \end{axis}
\end{tikzpicture}
\\
\subsection*{Выводы}

Хоть красно-черное дерево не является сбалансированным, оно гарантирует время удаления и вставки за O(log n) и, в отличе от АВЛ-дерева, требует лишь один дополнительный бит памяти на вершину (в АВЛ-дереве требуется два бита). Также можно заметить, что процедуру балансировки практически всегда можно выполнять параллельно с процедурами поиска, так как алгоритм поиска не зависит от атрибута цвета узлов.


\end{document}