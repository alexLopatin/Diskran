\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{ulem} 
% \usepackage{lmodern}
% \usepackage{textcomp}

\lstset{language=C++,
	basicstyle=\footnotesize\sffamily,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=false % переносить строки только если есть пробел
}
\parindent=1cm
\makeatletter

\newcommand{\print}[1]{{\large \textbf{#1}} 
{\scriptsize \lstinputlisting[]{../#1}}}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\linespread{1}
%\pgfplotsset{compat=1.16}
\begin{document}

\section*{\centering Лабораторная работа №\,8 по курсу:\\ Дискретный анализ}

Выполнил студент группы М8О-30XБ-17 МАИ \,\, \textit{Лопатин Александр}.

\subsection*{Задача}

Разработать жадный алгоритм решения задачи, определяемой своим
вариантом. Доказать его корректность, оценить скорость и объём
затрачиваемой оперативной памяти.
Реализовать программу на языке C или C++, соответствующую
построенному алгоритму. Формат входных и выходных данных описан в
варианте задания.


\paragraph*{Вариант 5:} Оптимальная сортировка чисел.\\
Дана последовательность длины N из целых чисел 1, 2, 3. Необходимо
найти минимальное количество обменов элементов последовательности,
в результате которых последовательность стала бы отсортированной.

\textit{\textbf{Входные данные:}} число N на первой строке и N чисел на второй строке.

\textit{ \textbf{Выходные данные:}}  минимальное количество обменов.

\subsection*{Информация}

Суть жадных алгоритмов состоит в принятии локально-оптимальных решений в надежде, что
конечное решение так же окажется оптимальным. Но не всегда применим жадный алгоритм, чтобы
доказать корректность его применения, нужно доказать что исследуемый объект является
матроидом.

Матроидом называется пара множеств $E$, $I$, состоящая из конечного множества $E$, называемого
базовым множеством матроида, и множества его подмножеств $I$, называемого множеством
независимых множеств матроида, причем $I$ удовлетворяет свойствам:
\begin{itemize}
	\item Множество $I$ не пусто. Даже если исходное множество $E$ было пусто -- $E = 0$, то $I$ будет состоять из одного элемента - множества, содержащего пустое $I = \{\{0\}\}$.
	\item Любое подмножество любого элемента множества $I$ также будет элементом этого
	      множества.
	\item Если $X, Y \in I$, причем $|X| = |Y| + 1$, тогда существует элемент
	      $x \in X\backslash Y$, такой что $Y \cup \{x\} \in I$.
\end{itemize}

\noindent Этапы построения алгоритма решения подзадач:
\begin{itemize}
	\item Описать структуру оптимального решения.
	\item Составить рекурсивное решение для нахождения оптимального решения.
	\item Вычисление значения, соответствующего оптимальному решению, методом
	      восходящего анализа.
	\item Непосредственное нахождение оптимального решения из полученной на предыдущих
	      этапах информации.
\end{itemize}

\subsection*{Метод решения}
В результате сортировки наша последовательность примет вид: $1, 1, ..., 2, 2, ..., 3, 3, ...$, причем вычислить индексы начала каждого из блока единиц, двоек или троек можно подсчетом единиц, двоек и троек. Разделим неотсортированную последовательность на такие же блоки. Заметим, что если в блоке, соответсвующем i, есть элементы i, то менять их не нужно, они уже стоят на своем месте. Если же в блоке i есть элемент j, не равный i, то находим в блоке j элемент i и меняем их. В результате данного обмена мы стали ближе к отсортированной последовательности, так как два элемента встали на свои места, причем мы сделали наименьшее возможное количество обменов. Если же в блоке j нет элемента i, то это значит, что элемент i есть в блоке k, не равном i и j. Меняем их местами. Встал на свое место только один элемент, чтобы встали на свое места элементы k и j, нужен еще один обмен. За два обмена встали на свои места 3 элемента. Однако в данном случае одного обмена никак не хватит, пример: 2 3 1. Таким образом, алгоритм принимает на каждом шаге локально-оптимальное решение, в надежде на то, что конечное решение будет оптимальным, и оно, как доказано выше по принципу жадного выбора, будет оптимальным.

\subsection*{Исходный код}
\print{lab8.cpp}
Из-за наличия вложенных циклов, сложность по времени оценивается $O(n^2)$
\subsection*{Генератор тестов}
\print{tests.py}

\subsection*{Тест производительности}

\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=Количество элементов, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 100000, 7.83 )
        ( 90000, 6.11 )
        ( 80000, 4.85 )
        ( 70000, 3.67 )
        ( 60000, 2.69 )
        ( 50000, 1.90 )
        ( 40000, 1.20 )
        ( 30000, 0.69 )
        ( 20000, 0.35 )
        ( 10000, 0.08  )};
    \end{axis}
\end{tikzpicture}

По графику видно, что сложность близка к квадратичной.\\
\subsection*{Выводы}

Жадный подход далеко не всегда дает оптимальное решение, но во многих случаях получаемое решение оказывается достаточно близким к оптимальному, а для некоторых задач известны и оптимальные жадные алгоримы (построение оптимального префиксного кода по Хаффману, построение остовного дерева максимального веса, планирование вычислений на процессоре с минимизацией ожидания и другие).


\end{document}