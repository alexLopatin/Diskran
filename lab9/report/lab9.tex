\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{ulem} 

\lstset{language=C++,
	basicstyle=\footnotesize\sffamily,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=false % переносить строки только если есть пробел
}
\parindent=1cm
\makeatletter

\newcommand{\print}[1]{{\large  \bf  #1} 
{\scriptsize \lstinputlisting[language=C++]{../#1}}}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\linespread{1}
%\pgfplotsset{compat=1.16}
\begin{document}

\section*{\centering Лабораторная работа №\,9 по курсу:\\ Дискретный анализ}

Выполнил студент группы М8О-307Б-17 МАИ \,\, \textit{Лопатин Александр}.

\subsection*{Задача}

\paragraph*{Вариант 3}: Поиск компонент связности\\
Задан неориентированный граф, состоящий из n вершин и m ребер.
Вершины пронумерованы целыми числами от 1 до n. Необходимо
вывести все компоненты связности данного графа.

\textit{ \textbf{Входные данные}}: 
В первой строке заданы 1 ≤ n ≤ 105, 1 ≤ m ≤ 105. В
следующих m строках записаны ребра. Каждая строка содержит пару
чисел – номера вершин, соединенных ребром.


\textit{ \textbf{Выходные данные}}: 
Каждую компоненту связности нужно выводить в отдельной строке, в
виде списка номеров вершин через пробел. Строки при выводе должны
быть отсортированы по минимальному номеру вершины в компоненте,
числа в одной строке также должны быть отсортированы.

\subsection*{Информация}

Компонента связности графа G (или просто компонента графа G) — максимальный (по включению) связный подграф графа G.

Другими словами, это подграф  G(U), порождённый множеством   $U \subseteq V(G)$ вершин, в котором для любой пары вершин  u, $v \in U$ в графе   G существует  (u,v)-цепь и для любой пары вершин  $u\in U$,  $w \notin U$ не существует  (u, w)-цепи.

Для ориентированных графов определено понятие компоненты сильной связности.



\subsection*{Метод решения}

Для того, чтобы выделить компоненты связности, нужно обойти все вершины графа. Для этой цели могут подойти алгоритмы обхода в ширину/глубину, но для простоты реализации алгоритма был выбран поиск в глубину. Достаточно для каждой вершины выполнить метод поиска в глубину, запомнить каждую обрабатываемую вершину и поменять её цвет. Во-первых, цвет нужен для работы поиска в глубину, а во-вторых, цвет вершины даст нам понять, была ли уже рассмотрена компонента связности, которой эта вершина принадлежит. Благодаря этому гарантируется сложность по времени $O(n*m)$, где n - количество вершин, m - количество ребер в графе.
\subsection*{Исходный код}

\print{lab9.cpp}

\subsection*{Генератор тестов}
Тесты создаются следующим образом: задается количество вершин, и наличие ребра у двух любых вершин задается с вероятностью 0.25. Это означает, что количество ребер m будет примерно равно 0.25n, т.е. будет расти линейно от n. \\ \\
\print{tests.py}

\subsection*{Тест производительности}
Так как сложность алгоритма поиска в глубину составляет $O(n*m)$, а m примерно равно 0.25n, то ожидаемое время работы будет расти квадратично. \\ \\

\begin{tikzpicture}
    \begin{axis}[ylabel=Время,xlabel=Количество вершин, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 1000, 0.30 )
        ( 900, 0.24 )
        ( 800, 0.19 )
        ( 700, 0.14 )
        ( 600, 0.11 )
        ( 500, 0.08 )
        ( 400, 0.05 )
        ( 300, 0.02 )
        ( 200, 0.01 )
        ( 100, 0.00  )};
    \end{axis}
\end{tikzpicture}
\\ \\
\begin{tikzpicture}
    \begin{axis}[ylabel=Килобайт,xlabel=Количество вершин, width=13.5cm, height=10cm,grid=both]
    \addplot coordinates {
        ( 1000, 5916 )
        ( 900, 5460 )
        ( 800, 5236 )
        ( 700, 4728 )
        ( 600, 4512 )
        ( 500, 4188 )
        ( 400, 4012 )
        ( 300, 3628 )
        ( 200, 3536 )
        ( 100, 3376  )};
    \end{axis}
\end{tikzpicture}
\\
\subsection*{Выводы}

Алгоритм поиска компонент связности достаточно прост, так как достаточно выполнить поиск в глубину для каждой вершины графа. Реализовать алгоритм поиска в глубину не составило труда.

\end{document}